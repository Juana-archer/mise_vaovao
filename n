#!/usr/bin/env python3
# run_bot.py - Script pour l'UTILISATEUR avec sauvegarde d'ID
import sys
import asyncio
import builtins
import os
import datetime
import json
import requests
import threading
import time
from pathlib import Path

print("="*70)
print("ü§ñ LANCEUR DU BOT")
print("="*70)

# ==================== CONFIGURATION ====================

ADMIN_API_URL = "http://10.216.132.49:5000"  # IP de ton serveur
CHECK_INTERVAL = 60  # V√©rification toutes les 60 secondes
CONFIG_FILE = Path(__file__).parent / "bot_config.json"  # Fichier de sauvegarde

# ==================== GESTION DE LA CONFIGURATION ====================

def load_config():
    """Charge la configuration sauvegard√©e"""
    if CONFIG_FILE.exists():
        try:
            with open(CONFIG_FILE, 'r') as f:
                return json.load(f)
        except:
            return {}
    return {}

def save_config(android_id):
    """Sauvegarde l'Android ID"""
    config = {
        'android_id': android_id,
        'saved_at': datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
        'auto_start': True
    }
    with open(CONFIG_FILE, 'w') as f:
        json.dump(config, f, indent=2)
    print(f"‚úÖ Android ID sauvegard√© dans {CONFIG_FILE}")

def clear_config():
    """Supprime la configuration"""
    if CONFIG_FILE.exists():
        CONFIG_FILE.unlink()
        print("üóëÔ∏è Configuration effac√©e")

# ==================== FONCTIONS DE V√âRIFICATION ====================

def verify_with_admin(android_id):
    """V√©rifie l'activation aupr√®s du serveur admin"""
    try:
        response = requests.post(f"{ADMIN_API_URL}/verify", json={
            "android_id": android_id
        }, timeout=5)
        
        if response.status_code == 200:
            data = response.json()
            return data.get('valid', False), data.get('message'), data.get('time_left')
        else:
            return False, f"Erreur de v√©rification", None
    except Exception as e:
        return False, f"Erreur de connexion: {e}", None

def expiration_monitor(android_id):
    """Surveille l'expiration en arri√®re-plan"""
    print(f"‚è∞ Surveillance d'expiration activ√©e (v√©rification toutes les {CHECK_INTERVAL}s)")
    
    while True:
        time.sleep(CHECK_INTERVAL)
        
        try:
            valid, message, time_left = verify_with_admin(android_id)
            
            if not valid:
                print("\n" + "!"*70)
                print("‚ùå SESSION EXPIR√âE !")
                print(message)
                print("Le bot va s'arr√™ter.")
                print("Suppression de la configuration...")
                clear_config()
                print("!"*70 + "\n")
                
                # Arr√™t forc√©
                os._exit(1)
                
            elif time_left and ("min" in time_left or "0j" in time_left):
                print(f"‚è≥ Temps restant: {time_left}")
                    
        except:
            pass

# ==================== PROGRAMME PRINCIPAL ====================

def main():
    # Charge la configuration existante
    config = load_config()
    android_id = config.get('android_id') if config else None
    
    # Si pas d'ID sauvegard√©, on demande
    if not android_id:
        print("\nüìù PREMI√àRE UTILISATION")
        print("-" * 40)
        android_id = input("üì± Entrez votre Android ID: ").strip()
        
        if not android_id:
            print("‚ùå Android ID requis")
            input("Appuyez sur Entr√©e pour quitter...")
            sys.exit(1)
        
        # Sauvegarde l'ID
        save_config(android_id)
        print("-" * 40)
    else:
        print(f"\nüì± Android ID sauvegard√©: {android_id}")
        print(f"üìÖ Sauvegard√© le: {config.get('saved_at')}")
        print("-" * 40)
    
    # V√©rification initiale
    print("\nüîç V√âRIFICATION DE L'ACTIVATION...")
    valid, message, time_left = verify_with_admin(android_id)
    
    if not valid:
        print("\n" + "!"*70)
        print(message)
        print("\nL'ID sauvegard√© n'est plus valide.")
        print("Suppression de la configuration...")
        clear_config()
        print("\nRelancez le programme pour entrer un nouvel ID.")
        print("!"*70 + "\n")
        input("Appuyez sur Entr√©e pour quitter...")
        sys.exit(1)
    else:
        print(f"\n‚úÖ ACTIVATION VALIDE")
        if time_left:
            print(f"‚è≥ Temps restant: {time_left}")
        print("üéØ Lancement automatique du bot...\n")
    
    # D√©marre le moniteur d'expiration
    monitor_thread = threading.Thread(target=expiration_monitor, args=(android_id,), daemon=True)
    monitor_thread.start()
    
    # BYPASS pour √©viter les arr√™ts intempestifs du task.py
    original_exit = sys.exit
    sys.exit = lambda *a, **k: None
    builtins.exit = lambda *a, **k: None
    builtins.quit = lambda *a, **k: None
    
    # Charge et ex√©cute task.py
    task_path = Path(__file__).parent / "task.py"
    
    if not task_path.exists():
        print(f"‚ùå Erreur: fichier task.py non trouv√©")
        print(f"Chemin cherch√©: {task_path}")
        input("Appuyez sur Entr√©e pour quitter...")
        sys.exit(1)
    
    try:
        with open(task_path, 'rb') as f:
            code = f.read().decode('utf-8', errors='ignore')
        print("‚úÖ Fichier task.py charg√©")
    except Exception as e:
        print(f"‚ùå Erreur: {e}")
        input("Appuyez sur Entr√©e pour quitter...")
        sys.exit(1)
    
    # Patch le code
    lines = code.split('\n')
    for i, line in enumerate(lines):
        if 'exec(m.loads(z.decompress(d)))' in line:
            lines[i] = '''
try:
    import marshal as m
    import zlib as z
    __decompressed = z.decompress(d)
    __loaded = m.loads(__decompressed)
    if __loaded:
        exec(__loaded)
except:
    pass
'''
            break
    
    patched_code = '\n'.join(lines)
    
    # Pr√©pare l'environnement
    env = {
        '__name__': '__main__',
        '__file__': str(task_path),
        'print': print,
        'ANDROID_ID': android_id,
    }
    
    # Ex√©cute le code pour charger les fonctions
    try:
        exec(patched_code, env)
    except Exception as e:
        print(f"‚ö†Ô∏è Warning lors du chargement: {e}")
    
    # Cherche une fonction √† ex√©cuter
    async_funcs = ['main', 'run', 'start', 'execute', 'bot', 'client']
    
    async def run_async_funcs():
        for func_name in async_funcs:
            if func_name in env and callable(env[func_name]):
                print(f"‚ñ∂ Lancement de {func_name}()...")
                try:
                    if asyncio.iscoroutinefunction(env[func_name]):
                        # Ex√©cution asynchrone
                        task = asyncio.create_task(env[func_name]())
                        
                        # Boucle de v√©rification
                        while not task.done():
                            await asyncio.sleep(1)
                            
                        result = task.result()
                    else:
                        # Ex√©cution synchrone
                        result = env[func_name]()
                    
                    print(f"‚úÖ Programme termin√©")
                    return True
                except Exception as e:
                    print(f"‚ö† Erreur dans {func_name}: {e}")
        return False
    
    # Lance le programme
    try:
        sys.exit = original_exit
        success = asyncio.run(run_async_funcs())
        
        if not success:
            print("\n‚Ñπ Aucune fonction principale trouv√©e dans task.py")
            print("Le fichier a √©t√© charg√© mais rien n'a √©t√© ex√©cut√©")
            
    except KeyboardInterrupt:
        print("\n\n‚èπÔ∏è Arr√™t demand√© par l'utilisateur")
    except Exception as e:
        print(f"\n‚ùå Erreur pendant l'ex√©cution: {e}")
    
    print("\n" + "="*70)
    print("Pour relancer le bot, r√©ex√©cutez simplement : python3 run_bot.py")
    print("="*70)

if __name__ == "__main__":
    main()
