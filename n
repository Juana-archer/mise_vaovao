#!/usr/bin/env python3
# run_bot.py - Version intelligente avec auto-update
# Pour les utilisateurs de @Juana-archer

import sys
import asyncio
import builtins
import os
import datetime
import json
import requests
import threading
import time
from pathlib import Path

print("="*70)
print("ü§ñ LANCEUR INTELLIGENT DU BOT")
print("="*70)

# ==================== CONFIGURATION AUTOMATIQUE ====================
# Gist de l'admin @Juana-archer - Mis √† jour automatiquement
GIST_URL = "https://gist.githubusercontent.com/Juana-archer/f2a6edaedf5fef169fb4a1f15833da3c/raw/067d32893a727c0f59c80794e5b9dd000071aa98/gist_config.json"

CONFIG_FILE = Path(__file__).parent / "bot_config.json"
CACHE_FILE = Path(__file__).parent / "server_cache.json"
CHECK_INTERVAL = 60
MAX_RETRIES = 3

# ==================== FONCTIONS DE MISE √Ä JOUR AUTOMATIQUE ====================

def get_server_config():
    """R√©cup√®re la configuration du serveur depuis le Gist de l'admin"""
    try:
        print("üåê R√©cup√©ration de la configuration serveur...")
        response = requests.get(GIST_URL, timeout=5)
        if response.status_code == 200:
            config = response.json()
            # Sauvegarde en cache
            with open(CACHE_FILE, 'w') as f:
                json.dump(config, f)
            print(f"‚úÖ Configuration re√ßue")
            print(f"üìÖ Derni√®re mise √† jour: {config.get('last_update', 'inconnue')}")
            print(f"üì± Admin: {config.get('admin_contact', '@Juana-archer')}")
            return config
        else:
            print("‚ö†Ô∏è Impossible de joindre le serveur de config")
            return None
    except Exception as e:
        print(f"‚ö†Ô∏è Erreur de connexion: {e}")
        return None

def load_cached_config():
    """Charge la configuration depuis le cache local"""
    try:
        with open(CACHE_FILE, 'r') as f:
            return json.load(f)
    except:
        return {"current_url": None, "backup_urls": []}

def find_active_server():
    """Trouve un serveur actif en testant toutes les URLs"""
    print("\nüîç RECHERCHE DU SERVEUR ACTIF")
    print("-" * 40)
    
    # Essaie d'abord de r√©cup√©rer la config en ligne
    config = get_server_config()
    
    if not config:
        print("üì¶ Utilisation du cache local")
        config = load_cached_config()
    
    # Construit la liste des URLs √† tester
    urls_to_test = []
    if config.get('current_url'):
        urls_to_test.append(config['current_url'])
        print(f"üìå URL principale: {config['current_url']}")
    
    backup_urls = config.get('backup_urls', [])
    if backup_urls:
        print(f"üìå URLs de secours: {len(backup_urls)}")
        urls_to_test.extend(backup_urls)
    
    print("-" * 40)
    
    # Teste chaque URL
    for i, url in enumerate(urls_to_test, 1):
        print(f"üîç Test {i}/{len(urls_to_test)}: {url[:50]}...")
        try:
            response = requests.get(f"{url}/", timeout=3)
            if response.status_code == 200:
                print(f"‚úÖ SERVEUR TROUV√â !")
                print(f"   ‚Üí {url}")
                return url
        except:
            continue
    
    return None

# ==================== FONCTIONS EXISTANTES ====================

def load_config():
    if CONFIG_FILE.exists():
        try:
            with open(CONFIG_FILE, 'r') as f:
                return json.load(f)
        except:
            return {}
    return {}

def save_config(android_id, server_url):
    config = {
        'android_id': android_id,
        'saved_at': datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
        'server_url': server_url
    }
    with open(CONFIG_FILE, 'w') as f:
        json.dump(config, f, indent=2)
    print(f"‚úÖ Configuration sauvegard√©e")

def clear_config():
    if CONFIG_FILE.exists():
        CONFIG_FILE.unlink()
        print("üóëÔ∏è Configuration effac√©e")

def verify_with_admin(server_url, android_id):
    for attempt in range(MAX_RETRIES):
        try:
            response = requests.post(
                f"{server_url}/verify", 
                json={"android_id": android_id},
                timeout=10
            )
            
            if response.status_code == 200:
                data = response.json()
                if data.get('valid'):
                    return True, data.get('message'), data.get('time_left')
                else:
                    return False, data.get('message', 'Compte invalide'), None
            else:
                return False, f"Erreur serveur ({response.status_code})", None
                
        except:
            if attempt < MAX_RETRIES - 1:
                time.sleep(2)
                continue
    
    return False, "‚ùå Connexion impossible", None

def monitor_server(server_url, android_id):
    print(f"‚è∞ Surveillance activ√©e")
    
    while True:
        time.sleep(CHECK_INTERVAL)
        
        # V√©rifie si le serveur est toujours l√†
        try:
            requests.get(f"{server_url}/", timeout=3)
        except:
            print("\n‚ö†Ô∏è Connexion perdue, recherche d'un nouveau serveur...")
            new_url = find_active_server()
            if new_url:
                print(f"‚úÖ Nouveau serveur: {new_url}")
                config = load_config()
                if config and 'android_id' in config:
                    save_config(config['android_id'], new_url)
                server_url = new_url
            else:
                print("‚ùå Aucun serveur trouv√©")
                print("üì± Contacte l'admin: @Juana-archer")
                os._exit(1)
        
        # V√©rifie l'expiration
        try:
            valid, message, time_left = verify_with_admin(server_url, android_id)
            if not valid:
                print("\n" + "!"*70)
                print("‚ùå SESSION EXPIR√âE")
                print(message)
                print("!"*70)
                os._exit(1)
        except:
            pass

def patch_task_code(code):
    lines = code.split('\n')
    for i, line in enumerate(lines):
        if 'exec(m.loads(z.decompress(d)))' in line:
            lines[i] = 'try:\n    import marshal as m\n    import zlib as z\n    exec(m.loads(z.decompress(d)))\nexcept:\n    pass'
            break
    return '\n'.join(lines)

# ==================== MAIN ====================

def main():
    print("\nüîç RECHERCHE DU SERVEUR...")
    print(f"üì± Admin: @Juana-archer")
    
    # Trouve le serveur actif
    SERVER_URL = find_active_server()
    
    if not SERVER_URL:
        print("\n" + "!"*70)
        print("‚ùå AUCUN SERVEUR TROUV√â")
        print("\nCauses possibles:")
        print("‚Ä¢ Le serveur de l'admin est √©teint")
        print("‚Ä¢ Ta connexion Internet ne fonctionne pas")
        print("‚Ä¢ Contacte l'admin: @Juana-archer")
        print("!"*70)
        input("\nAppuyez sur Entr√©e pour quitter...")
        sys.exit(1)
    
    print(f"\nüåê Connect√© √†: {SERVER_URL}")
    
    # Charge ou demande l'ID
    config = load_config()
    android_id = config.get('android_id') if config else None
    
    if not android_id:
        print("\nüìù PREMI√àRE UTILISATION")
        print("-" * 40)
        android_id = input("üì± Entrez votre Android ID: ").strip()
        if not android_id:
            print("‚ùå ID requis")
            sys.exit(1)
        save_config(android_id, SERVER_URL)
        print("-" * 40)
    else:
        print(f"\nüì± ID sauvegard√©: {android_id}")
    
    # V√©rification
    print("\nüîç V√âRIFICATION DE L'ACTIVATION...")
    valid, message, time_left = verify_with_admin(SERVER_URL, android_id)
    
    if not valid:
        print("\n" + "!"*70)
        print(message)
        print("\nContacte l'admin: @Juana-archer")
        print("!"*70)
        input("\nAppuyez sur Entr√©e pour quitter...")
        sys.exit(1)
    
    print(f"\n‚úÖ ACTIVATION VALIDE")
    if time_left:
        print(f"‚è≥ Temps restant: {time_left}")
    print("üéØ Lancement du bot...\n")
    
    # Lance la surveillance
    monitor_thread = threading.Thread(target=monitor_server, args=(SERVER_URL, android_id), daemon=True)
    monitor_thread.start()
    
    # Charge et lance task.py
    task_path = Path(__file__).parent / "task.py"
    
    if not task_path.exists():
        print(f"‚ùå Erreur: fichier task.py non trouv√©")
        print("Assure-toi que task.py est dans le m√™me dossier")
        input("Appuyez sur Entr√©e pour quitter...")
        sys.exit(1)
    
    try:
        with open(task_path, 'rb') as f:
            code = f.read().decode('utf-8', errors='ignore')
        print("‚úÖ Fichier task.py charg√©")
    except Exception as e:
        print(f"‚ùå Erreur: {e}")
        sys.exit(1)
    
    # BYPASS pour √©viter les arr√™ts intempestifs
    original_exit = sys.exit
    sys.exit = lambda *a, **k: None
    builtins.exit = lambda *a, **k: None
    builtins.quit = lambda *a, **k: None
    
    # Pr√©pare l'environnement
    env = {
        '__name__': '__main__',
        '__file__': str(task_path),
        'print': print,
        'ANDROID_ID': android_id,
    }
    
    # Ex√©cute le code
    try:
        exec(patch_task_code(code), env)
    except Exception as e:
        print(f"‚ö†Ô∏è Warning: {e}")
    
    # Cherche une fonction √† ex√©cuter
    async_funcs = ['main', 'run', 'start', 'execute', 'bot', 'client']
    
    async def run_async_funcs():
        for func_name in async_funcs:
            if func_name in env and callable(env[func_name]):
                print(f"‚ñ∂ Lancement de {func_name}()...")
                try:
                    if asyncio.iscoroutinefunction(env[func_name]):
                        await env[func_name]()
                    else:
                        env[func_name]()
                    return True
                except Exception as e:
                    print(f"‚ö† Erreur: {e}")
        return False
    
    # Lance le programme
    try:
        sys.exit = original_exit
        if asyncio.run(run_async_funcs()):
            print("\n‚úÖ Bot ex√©cut√© avec succ√®s")
        else:
            print("\n‚Ñπ Aucune fonction principale trouv√©e")
    except KeyboardInterrupt:
        print("\n\n‚èπÔ∏è Arr√™t demand√©")
    except Exception as e:
        print(f"\n‚ùå Erreur: {e}")
    
    print("\n" + "="*70)
    input("Appuyez sur Entr√©e pour fermer...")

if __name__ == "__main__":
    main()
