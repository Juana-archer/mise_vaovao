#!/usr/bin/env python3
# run_bot.py - Script pour l'UTILISATEUR avec sauvegarde d'ID
import sys
import asyncio
import builtins
import os
import datetime
import json
import requests
import threading
import time
import socket
from pathlib import Path

print("="*70)
print("ü§ñ LANCEUR DU BOT")
print("="*70)

# ==================== CONFIGURATION ====================

# URL de ton serveur via Cloudflare (obtenue avec cloudflared)
ADMIN_API_URL = "https://posing-raleigh-dinner-cooper.trycloudflare.com"

# Fichier de sauvegarde de l'ID
CONFIG_FILE = Path(__file__).parent / "bot_config.json"

# Intervalle de v√©rification d'expiration (en secondes)
CHECK_INTERVAL = 60
MAX_RETRIES = 3

# ==================== GESTION DE LA CONFIGURATION ====================

def load_config():
    """Charge la configuration sauvegard√©e"""
    if CONFIG_FILE.exists():
        try:
            with open(CONFIG_FILE, 'r') as f:
                return json.load(f)
        except:
            return {}
    return {}

def save_config(android_id):
    """Sauvegarde l'Android ID"""
    config = {
        'android_id': android_id,
        'saved_at': datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
        'server_url': ADMIN_API_URL
    }
    with open(CONFIG_FILE, 'w') as f:
        json.dump(config, f, indent=2)
    print(f"‚úÖ Android ID sauvegard√©")

def clear_config():
    """Supprime la configuration"""
    if CONFIG_FILE.exists():
        CONFIG_FILE.unlink()
        print("üóëÔ∏è Configuration effac√©e")

# ==================== FONCTIONS DE V√âRIFICATION ====================

def verify_with_admin(android_id):
    """V√©rifie l'activation aupr√®s du serveur admin"""
    for attempt in range(MAX_RETRIES):
        try:
            response = requests.post(
                f"{ADMIN_API_URL}/verify", 
                json={"android_id": android_id},
                timeout=10
            )
            
            if response.status_code == 200:
                data = response.json()
                if data.get('valid'):
                    return True, data.get('message'), data.get('time_left')
                else:
                    return False, data.get('message', 'Compte invalide'), None
            else:
                return False, f"Erreur serveur ({response.status_code})", None
                
        except requests.exceptions.ConnectionError:
            if attempt < MAX_RETRIES - 1:
                time.sleep(2)
                continue
            return False, "‚ùå Impossible de contacter le serveur. V√©rifie ta connexion Internet.", None
            
        except requests.exceptions.Timeout:
            if attempt < MAX_RETRIES - 1:
                time.sleep(2)
                continue
            return False, "‚ùå D√©lai d'attente d√©pass√©. Le serveur ne r√©pond pas.", None
            
        except Exception as e:
            return False, f"‚ùå Erreur: {str(e)}", None
    
    return False, "‚ùå √âchec de connexion apr√®s plusieurs tentatives", None

def expiration_monitor(android_id):
    """Surveille l'expiration en arri√®re-plan"""
    print(f"‚è∞ Surveillance d'expiration activ√©e (v√©rification toutes les {CHECK_INTERVAL}s)")
    
    while True:
        time.sleep(CHECK_INTERVAL)
        
        try:
            valid, message, time_left = verify_with_admin(android_id)
            
            if not valid:
                print("\n" + "!"*70)
                print("‚ùå SESSION EXPIR√âE OU SERVEUR INDISPONIBLE !")
                print(message)
                print("Le bot va s'arr√™ter.")
                print("!"*70 + "\n")
                
                # Supprime la configuration si le compte a expir√©
                if "expir√©" in message.lower():
                    clear_config()
                
                # Arr√™t forc√©
                os._exit(1)
                
            elif time_left and ("min" in time_left or "0j" in time_left):
                print(f"‚è≥ Temps restant: {time_left}")
                    
        except:
            pass

def patch_task_code(code):
    """Patche le code task.py pour √©viter les probl√®mes"""
    lines = code.split('\n')
    
    for i, line in enumerate(lines):
        if 'exec(m.loads(z.decompress(d)))' in line:
            lines[i] = '''
try:
    import marshal as m
    import zlib as z
    __decompressed = z.decompress(d)
    __loaded = m.loads(__decompressed)
    if __loaded:
        exec(__loaded)
except:
    pass  # Ignor√© silencieusement
'''
            break
    
    return '\n'.join(lines)

# ==================== PROGRAMME PRINCIPAL ====================

def main():
    print(f"üåê Serveur configur√©: {ADMIN_API_URL}")
    
    # Charge la configuration existante
    config = load_config()
    android_id = config.get('android_id') if config else None
    
    # Si pas d'ID sauvegard√©, on demande
    if not android_id:
        print("\nüìù PREMI√àRE UTILISATION")
        print("-" * 40)
        android_id = input("üì± Entrez votre Android ID: ").strip()
        
        if not android_id:
            print("‚ùå Android ID requis")
            input("Appuyez sur Entr√©e pour quitter...")
            sys.exit(1)
        
        # Sauvegarde l'ID
        save_config(android_id)
        print("-" * 40)
    else:
        print(f"\nüì± Android ID sauvegard√©: {android_id}")
        print(f"üìÖ Sauvegard√© le: {config.get('saved_at')}")
        print("-" * 40)
    
    # V√©rification initiale
    print("\nüîç V√âRIFICATION DE L'ACTIVATION...")
    valid, message, time_left = verify_with_admin(android_id)
    
    if not valid:
        print("\n" + "!"*70)
        print(message)
        print("\nProbl√®mes possibles:")
        print("1Ô∏è‚É£ L'ID est incorrect ou a expir√©")
        print("2Ô∏è‚É£ Le serveur n'est pas accessible")
        print("3Ô∏è‚É£ Ta connexion Internet ne fonctionne pas")
        print("!"*70 + "\n")
        
        choix = input("Voulez-vous effacer l'ID sauvegard√© ? (o/n): ")
        if choix.lower() == 'o':
            clear_config()
            print("Configuration effac√©e. Relance le programme.")
        
        input("Appuyez sur Entr√©e pour quitter...")
        sys.exit(1)
    else:
        print(f"\n‚úÖ ACTIVATION VALIDE")
        if time_left:
            print(f"‚è≥ Temps restant: {time_left}")
        print("üéØ Lancement du bot...\n")
    
    # D√©marre le moniteur d'expiration dans un thread s√©par√©
    monitor_thread = threading.Thread(target=expiration_monitor, args=(android_id,), daemon=True)
    monitor_thread.start()
    
    # BYPASS pour √©viter les arr√™ts intempestifs du task.py
    original_exit = sys.exit
    sys.exit = lambda *a, **k: None
    builtins.exit = lambda *a, **k: None
    builtins.quit = lambda *a, **k: None
    
    # Charge le fichier task.py
    task_path = Path(__file__).parent / "task.py"
    
    if not task_path.exists():
        print(f"‚ùå Erreur: fichier task.py non trouv√© dans {task_path.parent}")
        print("Assure-toi que task.py est dans le m√™me dossier que run_bot.py")
        input("Appuyez sur Entr√©e pour quitter...")
        sys.exit(1)
    
    try:
        with open(task_path, 'rb') as f:
            code = f.read().decode('utf-8', errors='ignore')
        print("‚úÖ Fichier task.py charg√©")
    except Exception as e:
        print(f"‚ùå Erreur lors du chargement de task.py: {e}")
        input("Appuyez sur Entr√©e pour quitter...")
        sys.exit(1)
    
    # Patche le code
    patched_code = patch_task_code(code)
    
    # Pr√©pare l'environnement
    env = {
        '__name__': '__main__',
        '__file__': str(task_path),
        'print': print,
        'ANDROID_ID': android_id,
    }
    
    # Ex√©cute le code pour charger les fonctions
    try:
        exec(patched_code, env)
    except Exception as e:
        print(f"‚ö†Ô∏è Warning lors du chargement: {e}")
    
    # Cherche une fonction √† ex√©cuter
    async_funcs = ['main', 'run', 'start', 'execute', 'bot', 'client']
    
    async def run_async_funcs():
        for func_name in async_funcs:
            if func_name in env and callable(env[func_name]):
                print(f"‚ñ∂ Lancement de {func_name}()...")
                try:
                    if asyncio.iscoroutinefunction(env[func_name]):
                        # Ex√©cution asynchrone avec v√©rification p√©riodique
                        task = asyncio.create_task(env[func_name]())
                        
                        # Boucle de v√©rification
                        while not task.done():
                            await asyncio.sleep(1)
                            
                        result = task.result()
                    else:
                        # Ex√©cution synchrone
                        result = env[func_name]()
                    
                    print(f"‚úÖ Programme termin√©")
                    return True
                except Exception as e:
                    print(f"‚ö† Erreur dans {func_name}: {e}")
        return False
    
    # Lance le programme
    try:
        # Restaure la fonction exit pour le programme
        sys.exit = original_exit
        
        # Ex√©cute
        if asyncio.run(run_async_funcs()):
            print("\n‚úÖ Bot ex√©cut√© avec succ√®s")
        else:
            print("\n‚Ñπ Aucune fonction principale trouv√©e dans task.py")
            print("Le fichier a √©t√© charg√© mais rien n'a √©t√© ex√©cut√©")
            print("Fonctions disponibles:", [f for f in env if callable(env[f]) and not f.startswith('_')][:10])
            
    except KeyboardInterrupt:
        print("\n\n‚èπÔ∏è Arr√™t demand√© par l'utilisateur")
    except Exception as e:
        print(f"\n‚ùå Erreur pendant l'ex√©cution: {e}")
    
    print("\n" + "="*70)
    print("Pour relancer le bot, ex√©cute simplement : python3 run_bot.py")
    print("="*70)

if __name__ == "__main__":
    main()
