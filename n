#!/usr/bin/env python3
# run_bot.py - Lanceur ultra-robuste avec gestion avancÃ©e des erreurs
# Version 3.0 - Pour les utilisateurs de @Juana-archer

import sys
import asyncio
import builtins
import os
import datetime
import json
import requests
import threading
import time
import random
import socket
from pathlib import Path
from typing import Optional, Dict, Any, Tuple, List

# ==================== CONFIGURATION AVANCÃ‰E ====================
GIST_ID = "f2a6edaedf5fef169fb4a1f15833da3c"
GIST_OWNER = "Juana-archer"
GIST_URL = f"https://gist.githubusercontent.com/{GIST_OWNER}/{GIST_ID}/raw/gist_config.json"

# Fichiers de configuration
CONFIG_DIR = Path(__file__).parent
CONFIG_FILE = CONFIG_DIR / "bot_config.json"
CACHE_FILE = CONFIG_DIR / "server_cache.json"
URL_HISTORY_FILE = CONFIG_DIR / "url_history.txt"
LOG_FILE = CONFIG_DIR / "bot.log"
ERROR_LOG_FILE = CONFIG_DIR / "error.log"

# ParamÃ¨tres de robustesse
CHECK_INTERVAL = 20 * 60  # 20 MINUTES (modifiÃ© de 120 Ã  1200 secondes)
MAX_RETRIES = 5
SERVER_TIMEOUT = 8
CONNECTION_RETRY_DELAY = 5
MAX_HISTORY_URLS = 20
HEALTH_CHECK_ENDPOINTS = ["/", "/health", "/status"]

# ==================== COULEURS (optionnel) ====================
try:
    import colorama
    colorama.init()
    Colors = type('Colors', (), {
        'HEADER': '\033[95m',
        'BLUE': '\033[94m',
        'CYAN': '\033[96m',
        'GREEN': '\033[92m',
        'YELLOW': '\033[93m',
        'RED': '\033[91m',
        'MAGENTA': '\033[35m',
        'BOLD': '\033[1m',
        'END': '\033[0m'
    })
except ImportError:
    # Pas de couleurs si colorama n'est pas installÃ©
    Colors = type('Colors', (), {
        'HEADER': '', 'BLUE': '', 'CYAN': '', 'GREEN': '', 
        'YELLOW': '', 'RED': '', 'MAGENTA': '', 'BOLD': '', 'END': ''
    })

# ==================== LOGGER ====================
class Logger:
    """SystÃ¨me de logging avancÃ©"""
    
    @staticmethod
    def log(message: str, level: str = "INFO"):
        timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        log_entry = f"[{timestamp}] [{level}] {message}"
        
        # Ã‰crire dans le fichier de log
        try:
            with open(LOG_FILE, 'a', encoding='utf-8') as f:
                f.write(log_entry + "\n")
        except:
            pass
        
        # Afficher avec couleur selon le niveau
        if level == "ERROR":
            print(f"{Colors.RED}{log_entry}{Colors.END}")
        elif level == "WARNING":
            print(f"{Colors.YELLOW}{log_entry}{Colors.END}")
        elif level == "SUCCESS":
            print(f"{Colors.GREEN}{log_entry}{Colors.END}")
        else:
            print(log_entry)
    
    @staticmethod
    def error(message: str):
        Logger.log(message, "ERROR")
        # Ã‰crire aussi dans error.log
        try:
            with open(ERROR_LOG_FILE, 'a', encoding='utf-8') as f:
                f.write(f"[{datetime.datetime.now()}] {message}\n")
        except:
            pass
    
    @staticmethod
    def success(message: str):
        Logger.log(message, "SUCCESS")
    
    @staticmethod
    def warning(message: str):
        Logger.log(message, "WARNING")

# ==================== GESTIONNAIRE DE RÃ‰SEAU ====================
class NetworkManager:
    """GÃ¨re toutes les opÃ©rations rÃ©seau avec retry et fallback"""
    
    @staticmethod
    def check_internet() -> bool:
        """VÃ©rifie si la connexion Internet est active"""
        try:
            # Test de connexion Ã  plusieurs endpoints fiables
            test_hosts = ['8.8.8.8', '1.1.1.1', 'github.com']
            for host in test_hosts:
                try:
                    socket.create_connection((host, 80), timeout=3)
                    return True
                except:
                    continue
            return False
        except:
            return False
    
    @staticmethod
    def safe_request(method: str, url: str, **kwargs) -> Optional[requests.Response]:
        """Effectue une requÃªte HTTP avec retry automatique"""
        default_kwargs = {
            'timeout': SERVER_TIMEOUT,
            'headers': {'User-Agent': 'Mozilla/5.0 (compatible; Bot/3.0)'}
        }
        default_kwargs.update(kwargs)
        
        for attempt in range(MAX_RETRIES):
            try:
                response = requests.request(method, url, **default_kwargs)
                
                # Log la requÃªte (sans les donnÃ©es sensibles)
                Logger.log(f"ğŸŒ {method} {url} -> {response.status_code}")
                
                return response
            except requests.exceptions.ConnectionError:
                if attempt < MAX_RETRIES - 1:
                    delay = CONNECTION_RETRY_DELAY * (attempt + 1)
                    Logger.warning(f"Connexion Ã©chouÃ©e, nouvelle tentative dans {delay}s...")
                    time.sleep(delay)
                else:
                    Logger.error(f"Connexion impossible aprÃ¨s {MAX_RETRIES} tentatives: {url}")
            except requests.exceptions.Timeout:
                Logger.warning(f"Timeout sur {url}")
                if attempt < MAX_RETRIES - 1:
                    time.sleep(CONNECTION_RETRY_DELAY)
            except Exception as e:
                Logger.error(f"Erreur requÃªte: {e}")
                break
        
        return None
    
    @staticmethod
    def get_with_fallback(urls: List[str], endpoint: str = "/") -> Optional[str]:
        """Teste plusieurs URLs et retourne la premiÃ¨re qui rÃ©pond"""
        for url in urls:
            full_url = url.rstrip('/') + endpoint
            response = NetworkManager.safe_request('GET', full_url)
            
            if response and response.status_code == 200:
                Logger.success(f"Serveur actif: {url}")
                return url
        
        return None

# ==================== GESTIONNAIRE DE CONFIGURATION ====================
class ConfigManager:
    """GÃ¨re la configuration et le cache"""
    
    @staticmethod
    def get_server_config() -> Optional[Dict[str, Any]]:
        """RÃ©cupÃ¨re la configuration depuis le Gist"""
        if not NetworkManager.check_internet():
            Logger.warning("Pas de connexion Internet, utilisation du cache")
            return ConfigManager.load_cached_config()
        
        Logger.log("ğŸŒ RÃ©cupÃ©ration de la configuration...")
        response = NetworkManager.safe_request('GET', GIST_URL)
        
        if response and response.status_code == 200:
            try:
                config = response.json()
                
                # Sauvegarde en cache
                ConfigManager.save_to_cache(config)
                
                # Sauvegarde dans l'historique
                ConfigManager.save_to_history(config.get('current_url'))
                
                Logger.success("Configuration rÃ©cupÃ©rÃ©e")
                return config
            except json.JSONDecodeError:
                Logger.error("Format JSON invalide")
        
        Logger.warning("Utilisation du cache local")
        return ConfigManager.load_cached_config()
    
    @staticmethod
    def save_to_cache(config: Dict[str, Any]):
        """Sauvegarde la config dans le cache"""
        try:
            with open(CACHE_FILE, 'w') as f:
                json.dump({
                    'config': config,
                    'timestamp': datetime.datetime.now().isoformat(),
                    'version': '3.0'
                }, f, indent=2)
        except Exception as e:
            Logger.error(f"Impossible de sauvegarder le cache: {e}")
    
    @staticmethod
    def load_cached_config() -> Dict[str, Any]:
        """Charge la config depuis le cache"""
        default_config = {
            "current_url": None,
            "backup_urls": [],
            "admin_contact": "@Juana-archer",
            "last_update": "inconnue"
        }
        
        try:
            if CACHE_FILE.exists():
                with open(CACHE_FILE, 'r') as f:
                    data = json.load(f)
                    return data.get('config', default_config)
        except Exception as e:
            Logger.error(f"Erreur chargement cache: {e}")
        
        return default_config
    
    @staticmethod
    def save_to_history(url: Optional[str]):
        """Sauvegarde l'URL dans l'historique"""
        if not url:
            return
        
        try:
            # Lit l'historique existant
            history = []
            if URL_HISTORY_FILE.exists():
                with open(URL_HISTORY_FILE, 'r') as f:
                    history = f.read().splitlines()
            
            # Ajoute la nouvelle URL avec timestamp
            entry = f"{datetime.datetime.now().isoformat()} | {url}"
            history.insert(0, entry)
            
            # Garde seulement les MAX_HISTORY_URLS plus rÃ©centes
            history = history[:MAX_HISTORY_URLS]
            
            # Sauvegarde
            with open(URL_HISTORY_FILE, 'w') as f:
                f.write("\n".join(history))
        except Exception as e:
            Logger.error(f"Erreur sauvegarde historique: {e}")
    
    @staticmethod
    def load_user_config() -> Dict[str, Any]:
        """Charge la configuration utilisateur"""
        default_config = {
            'android_id': None,
            'saved_at': None,
            'last_server': None
        }
        
        try:
            if CONFIG_FILE.exists():
                with open(CONFIG_FILE, 'r') as f:
                    return json.load(f)
        except Exception as e:
            Logger.error(f"Erreur chargement config utilisateur: {e}")
        
        return default_config
    
    @staticmethod
    def save_user_config(android_id: str, server_url: str):
        """Sauvegarde la configuration utilisateur"""
        try:
            config = {
                'android_id': android_id,
                'saved_at': datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
                'last_server': server_url,
                'version': '3.0'
            }
            with open(CONFIG_FILE, 'w') as f:
                json.dump(config, f, indent=2)
            Logger.success("Configuration utilisateur sauvegardÃ©e")
        except Exception as e:
            Logger.error(f"Erreur sauvegarde config: {e}")
    
    @staticmethod
    def clear_user_config():
        """Efface la configuration utilisateur"""
        try:
            if CONFIG_FILE.exists():
                CONFIG_FILE.unlink()
                Logger.log("Configuration effacÃ©e")
        except Exception as e:
            Logger.error(f"Erreur effacement config: {e}")

# ==================== GESTIONNAIRE DE SERVEUR ====================
class ServerManager:
    """GÃ¨re la recherche et la surveillance des serveurs"""
    
    def __init__(self):
        self.current_url = None
        self.backup_urls = []
        self.admin_contact = "@Juana-archer"
    
    def update_from_config(self, config: Dict[str, Any]):
        """Met Ã  jour les URLs depuis la config"""
        self.current_url = config.get('current_url')
        self.backup_urls = config.get('backup_urls', [])
        self.admin_contact = config.get('admin_contact', '@Juana-archer')
    
    def get_all_urls(self) -> List[str]:
        """Retourne toutes les URLs disponibles"""
        urls = []
        if self.current_url:
            urls.append(self.current_url)
        urls.extend(self.backup_urls)
        return urls
    
    def find_active_server(self) -> Optional[str]:
        """Trouve un serveur actif"""
        Logger.log("\nğŸ” RECHERCHE DU SERVEUR ACTIF")
        
        # RÃ©cupÃ¨re la configuration
        config = ConfigManager.get_server_config()
        self.update_from_config(config)
        
        urls = self.get_all_urls()
        
        if not urls:
            Logger.error("Aucune URL configurÃ©e")
            return None
        
        Logger.log(f"ğŸ“Œ {len(urls)} URLs Ã  tester")
        
        # Teste chaque endpoint de santÃ© pour chaque URL
        for endpoint in HEALTH_CHECK_ENDPOINTS:
            Logger.log(f"Test endpoint: {endpoint}")
            
            for url in urls:
                full_url = url.rstrip('/') + endpoint
                response = NetworkManager.safe_request('GET', full_url)
                
                if response and response.status_code == 200:
                    Logger.success(f"Serveur actif: {url}")
                    return url
                
                # Petit dÃ©lai entre les tests
                time.sleep(0.5)
        
        Logger.error("Aucun serveur trouvÃ©")
        return None
    
    def verify_license(self, server_url: str, android_id: str) -> Tuple[bool, Optional[str], Optional[str]]:
        """VÃ©rifie la licence auprÃ¨s du serveur"""
        Logger.log("ğŸ” VÃ©rification de la licence...")
        
        try:
            response = NetworkManager.safe_request(
                'POST',
                f"{server_url}/verify",
                json={"android_id": android_id},
                timeout=10
            )
            
            if response and response.status_code == 200:
                data = response.json()
                valid = data.get('valid', False)
                message = data.get('message', '')
                time_left = data.get('time_left')
                
                if valid:
                    Logger.success("Licence valide")
                    if time_left:
                        Logger.log(f"â³ Temps restant: {time_left}")
                else:
                    Logger.error(f"Licence invalide: {message}")
                
                return valid, message, time_left
            else:
                status = response.status_code if response else "pas de rÃ©ponse"
                Logger.error(f"Erreur serveur: {status}")
                return False, f"Erreur serveur ({status})", None
                
        except Exception as e:
            Logger.error(f"Erreur vÃ©rification: {e}")
            return False, str(e), None

# ==================== SURVEILLANCE ====================
class Monitor:
    """Surveillance en arriÃ¨re-plan"""
    
    def __init__(self, server_manager: ServerManager, android_id: str):
        self.server_manager = server_manager
        self.android_id = android_id
        self.running = True
    
    def start(self):
        """DÃ©marre la surveillance"""
        thread = threading.Thread(target=self._monitor_loop, daemon=True)
        thread.start()
        # Modification ici : message adaptÃ© Ã  20 minutes
        Logger.log(f"â° Surveillance activÃ©e (vÃ©rification toutes les 20 minutes)")
    
    def _monitor_loop(self):
        """Boucle de surveillance"""
        while self.running:
            time.sleep(CHECK_INTERVAL)
            
            try:
                self._check_server_health()
                self._check_license_expiry()
            except Exception as e:
                Logger.error(f"Erreur dans la boucle de surveillance: {e}")
    
    def _check_server_health(self):
        """VÃ©rifie la santÃ© du serveur"""
        if not self.server_manager.current_url:
            return
        
        Logger.log("ğŸ©º VÃ©rification santÃ© serveur...")
        
        # Teste l'URL actuelle
        for endpoint in HEALTH_CHECK_ENDPOINTS:
            url = self.server_manager.current_url.rstrip('/') + endpoint
            response = NetworkManager.safe_request('GET', url, timeout=5)
            
            if response and response.status_code == 200:
                Logger.log("âœ… Serveur OK")
                return
        
        # Serveur actuel HS, cherche un nouveau
        Logger.warning("âš ï¸ Serveur actuel inaccessible")
        new_url = self.server_manager.find_active_server()
        
        if new_url:
            Logger.success(f"Nouveau serveur: {new_url}")
            self.server_manager.current_url = new_url
            
            # Met Ã  jour la config
            config = ConfigManager.load_user_config()
            if config.get('android_id'):
                ConfigManager.save_user_config(config['android_id'], new_url)
        else:
            Logger.error("âŒ Aucun serveur de secours disponible")
    
    def _check_license_expiry(self):
        """VÃ©rifie si la licence a expirÃ©"""
        if not self.server_manager.current_url:
            return
        
        valid, message, _ = self.server_manager.verify_license(
            self.server_manager.current_url, 
            self.android_id
        )
        
        if not valid:
            Logger.error("\n" + "!"*70)
            Logger.error("âŒ SESSION EXPIRÃ‰E!")
            Logger.error(message)
            Logger.error("!"*70)
            
            # Nettoie la config si nÃ©cessaire
            if "expirÃ©" in message.lower():
                ConfigManager.clear_user_config()
            
            os._exit(1)

# ==================== EXÃ‰CUTEUR DE TASK ====================
class TaskExecutor:
    """ExÃ©cute le fichier task.py de faÃ§on sÃ©curisÃ©e"""
    
    def __init__(self, android_id: str):
        self.android_id = android_id
        self.task_path = Path(__file__).parent / "task.py"
    
    def execute(self) -> bool:
        """ExÃ©cute le task.py et retourne le succÃ¨s"""
        
        # VÃ©rifie que task.py existe
        if not self.task_path.exists():
            Logger.error(f"âŒ Fichier task.py non trouvÃ©!")
            return False
        
        # Charge le fichier
        try:
            with open(self.task_path, 'rb') as f:
                code = f.read().decode('utf-8', errors='ignore')
            Logger.success("Fichier task.py chargÃ©")
        except Exception as e:
            Logger.error(f"Erreur chargement: {e}")
            return False
        
        # Patche le code
        code = self._patch_code(code)
        
        # PrÃ©pare l'environnement
        env = self._prepare_environment()
        
        # ExÃ©cute
        try:
            exec(code, env)
        except Exception as e:
            Logger.warning(f"Warning pendant l'exÃ©cution: {e}")
        
        # Cherche et exÃ©cute la fonction principale
        return self._run_main_function(env)
    
    def _patch_code(self, code: str) -> str:
        """Patche le code pour Ã©viter les problÃ¨mes"""
        lines = code.split('\n')
        
        for i, line in enumerate(lines):
            if 'exec(m.loads(z.decompress(d)))' in line:
                lines[i] = '''
try:
    import marshal as m
    import zlib as z
    __decompressed = z.decompress(d)
    __loaded = m.loads(__decompressed)
    if __loaded:
        exec(__loaded)
except Exception:
    pass  # IgnorÃ© silencieusement
'''
                break
        
        return '\n'.join(lines)
    
    def _prepare_environment(self) -> Dict[str, Any]:
        """PrÃ©pare l'environnement d'exÃ©cution"""
        # Bypass des fonctions de sortie
        original_exit = sys.exit
        sys.exit = lambda *a, **k: None
        builtins.exit = lambda *a, **k: None
        builtins.quit = lambda *a, **k: None
        
        return {
            '__name__': '__main__',
            '__file__': str(self.task_path),
            'print': print,
            'ANDROID_ID': self.android_id,
            '_original_exit': original_exit  # Sauvegarde pour restauration
        }
    
    def _run_main_function(self, env: Dict[str, Any]) -> bool:
        """Cherche et exÃ©cute la fonction principale"""
        async_funcs = ['main', 'run', 'start', 'execute', 'bot', 'client']
        
        async def run_async():
            for func_name in async_funcs:
                if func_name in env and callable(env[func_name]):
                    Logger.log(f"â–¶ Lancement de {func_name}()...")
                    try:
                        if asyncio.iscoroutinefunction(env[func_name]):
                            await env[func_name]()
                        else:
                            env[func_name]()
                        return True
                    except Exception as e:
                        Logger.warning(f"Erreur dans {func_name}: {e}")
            return False
        
        try:
            # Restaure sys.exit
            if '_original_exit' in env:
                sys.exit = env['_original_exit']
            
            return asyncio.run(run_async())
        except KeyboardInterrupt:
            Logger.log("\n\nğŸ‘‹ ArrÃªt demandÃ©")
            return True
        except Exception as e:
            Logger.error(f"Erreur: {e}")
            return False

# ==================== INTERFACE UTILISATEUR ====================
class UserInterface:
    """GÃ¨re les interactions avec l'utilisateur"""
    
    @staticmethod
    def show_welcome():
        """Affiche le message de bienvenue"""
        now = datetime.datetime.now()
        
        welcome = f"""
{Colors.BOLD}{Colors.CYAN}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—{Colors.END}
{Colors.BOLD}{Colors.CYAN}â•‘{Colors.END}     ğŸš€ SMM BOT - @Juana-archer                         {Colors.BOLD}{Colors.CYAN}â•‘{Colors.END}
{Colors.BOLD}{Colors.CYAN}â•‘{Colors.END}     ğŸ“± Version 3.0 - Ultra Robuste                     {Colors.BOLD}{Colors.CYAN}â•‘{Colors.END}
{Colors.BOLD}{Colors.CYAN}â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£{Colors.END}
{Colors.BOLD}{Colors.CYAN}â•‘{Colors.END}     {Colors.MAGENTA}ğŸ“… {now.strftime('%d/%m/%Y')} Ã  {now.strftime('%H:%M:%S')}{Colors.END}                             {Colors.BOLD}{Colors.CYAN}â•‘{Colors.END}
{Colors.BOLD}{Colors.CYAN}â•‘{Colors.END}     {Colors.GREEN}ğŸŒ Recherche automatique du serveur{Colors.END}               {Colors.BOLD}{Colors.CYAN}â•‘{Colors.END}
{Colors.BOLD}{Colors.CYAN}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•{Colors.END}
"""
        print(welcome)
    
    @staticmethod
    def get_android_id() -> Optional[str]:
        """Demande l'Android ID Ã  l'utilisateur"""
        print(f"\n{Colors.BOLD}{Colors.BLUE}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—{Colors.END}")
        print(f"{Colors.BOLD}{Colors.BLUE}â•‘{Colors.END}              ğŸ“ PREMIÃˆRE CONNEXION                       {Colors.BOLD}{Colors.BLUE}â•‘{Colors.END}")
        print(f"{Colors.BOLD}{Colors.BLUE}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•{Colors.END}\n")
        
        android_id = input(f"{Colors.YELLOW}ğŸ“± Entrez votre Android ID: {Colors.END}").strip()
        
        if not android_id:
            print(f"{Colors.RED}âŒ Android ID requis{Colors.END}")
            return None
        
        return android_id
    
    @staticmethod
    def show_activation_success(android_id: str, time_left: Optional[str] = None):
        """Affiche le succÃ¨s de l'activation"""
        msg = f"""
{Colors.BOLD}{Colors.GREEN}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—{Colors.END}
{Colors.BOLD}{Colors.GREEN}â•‘{Colors.END}              âœ… ACTIVATION RÃ‰USSIE                        {Colors.BOLD}{Colors.GREEN}â•‘{Colors.END}
{Colors.BOLD}{Colors.GREEN}â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£{Colors.END}
{Colors.BOLD}{Colors.GREEN}â•‘{Colors.END}  ğŸ“± Android ID: {android_id[:8]}...{android_id[-4:]}                              {Colors.BOLD}{Colors.GREEN}â•‘{Colors.END}
"""
        if time_left:
            msg += f"{Colors.BOLD}{Colors.GREEN}â•‘{Colors.END}  â³ {time_left}                                    {Colors.BOLD}{Colors.GREEN}â•‘{Colors.END}\n"
        
        msg += f"""{Colors.BOLD}{Colors.GREEN}â•‘{Colors.END}  ğŸ‘¤ Support: @Juana-archer                               {Colors.BOLD}{Colors.GREEN}â•‘{Colors.END}
{Colors.BOLD}{Colors.GREEN}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•{Colors.END}
"""
        print(msg)
    
    @staticmethod
    def show_error(message: str, suggest_clear: bool = False):
        """Affiche une erreur"""
        print(f"\n{Colors.RED}{'!'*70}{Colors.END}")
        print(f"{Colors.RED}âŒ {message}{Colors.END}")
        print(f"{Colors.RED}{'!'*70}{Colors.END}\n")
        
        if suggest_clear:
            choix = input("Effacer l'ID sauvegardÃ© ? (o/n): ")
            if choix.lower() == 'o':
                ConfigManager.clear_user_config()
        
        input(f"{Colors.CYAN}Appuyez sur EntrÃ©e pour quitter...{Colors.END}")

# ==================== PROGRAMME PRINCIPAL ====================
def main():
    # Affiche l'en-tÃªte
    UserInterface.show_welcome()
    
    # VÃ©rifie la connexion Internet
    if not NetworkManager.check_internet():
        UserInterface.show_error("Pas de connexion Internet dÃ©tectÃ©e!")
        sys.exit(1)
    
    # Initialise le gestionnaire de serveur
    server_manager = ServerManager()
    
    # Trouve un serveur actif
    server_url = server_manager.find_active_server()
    
    if not server_url:
        UserInterface.show_error(
            "AUCUN SERVEUR DISPONIBLE\n\n"
            "Causes possibles:\n"
            "â€¢ Le serveur de l'admin est Ã©teint\n"
            "â€¢ Le Gist de configuration est inaccessible\n"
            "â€¢ Contacte l'admin @Juana-archer"
        )
        sys.exit(1)
    
    Logger.success(f"ConnectÃ© Ã : {server_url}")
    
    # Charge ou demande l'Android ID
    user_config = ConfigManager.load_user_config()
    android_id = user_config.get('android_id')
    
    if not android_id:
        android_id = UserInterface.get_android_id()
        if not android_id:
            sys.exit(1)
        ConfigManager.save_user_config(android_id, server_url)
    else:
        Logger.log(f"ğŸ“± ID sauvegardÃ©: {android_id}")
    
    # VÃ©rifie la licence
    valid, message, time_left = server_manager.verify_license(server_url, android_id)
    
    if not valid:
        UserInterface.show_error(
            f"{message}\n\nContacte l'admin @Juana-archer",
            suggest_clear=True
        )
        sys.exit(1)
    
    # Affiche le succÃ¨s
    UserInterface.show_activation_success(android_id, time_left)
    print(f"{Colors.GREEN}ğŸ¯ Lancement du bot...{Colors.END}\n")
    
    # DÃ©marre la surveillance
    monitor = Monitor(server_manager, android_id)
    monitor.start()
    
    # ExÃ©cute le task.py
    executor = TaskExecutor(android_id)
    success = executor.execute()
    
    if not success:
        Logger.warning("Aucune fonction principale trouvÃ©e dans task.py")
    
    Logger.log("\n" + "="*70)
    Logger.log("Bot terminÃ© - Pour relancer: python3 run_bot.py")
    Logger.log("="*70)

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print(f"\n\n{Colors.YELLOW}ğŸ‘‹ ArrÃªt du bot - Ã€ bientÃ´t !{Colors.END}")
    except Exception as e:
        Logger.error(f"Erreur fatale: {e}")
        import traceback
        traceback.print_exc()
        input("\nAppuyez sur EntrÃ©e pour quitter...")
